# ğŸ‘©ğŸ¼â€ğŸ’» C# EÄÄ°TÄ°M KAMPI

Murat YÃ¼cedaÄŸ'Ä±n [C# EÄŸitim KampÄ±](https://youtube.com/playlist?list=PLKnjBHu2xXNPmFMvGKVHA_ijjrgUyNIXr&si=cLyDHRSu0go-YLPt) online kursundan, C# Ã¼zerine eÄŸitim aldÄ±ÄŸÄ±m ve Ã¶ÄŸrenirken yaptÄ±klarÄ±mÄ± notlar aldÄ±ÄŸÄ±m repodur.

# Repo Ä°Ã§erikleri:

## 1. Temel Konular | Main Subjects ğŸ“š
+ Bu projede yazdÄ±rma komutlarÄ±, string ve int deÄŸiÅŸkenler bahsedilmiÅŸtir. `Console.WriteLine()` yazdÄ±rma komutu ile deÄŸiÅŸkenlerin ekrana yazÄ±lÄ±ÅŸÄ± gÃ¶sterilmiÅŸtir.
+ Temel C# yapÄ±larÄ±nÄ± ve veri tiplerini anlamak, programlamanÄ±n temellerini kavramak iÃ§in kritik Ã¶neme sahiptir.ğŸ“–

## 2. DeÄŸiÅŸkenler | Variables ğŸ“Š
+ Bu projede double ve char deÄŸiÅŸkenler ve veri giriÅŸlerinden bahsedilmiÅŸtir. `Console.ReadLine` komutu ile `Parse` metodu kullanÄ±mÄ± gÃ¶sterilmiÅŸtir.
+ DeÄŸiÅŸkenler, program iÃ§inde veri saklamayÄ± ve manipÃ¼le etmeyi mÃ¼mkÃ¼n kÄ±lar, bu nedenle veri tiplerinin doÄŸru seÃ§imi Ã¶nemlidir.ğŸ”¢

## 3. Karar YapÄ±larÄ± | Making Decision ğŸ§ 
+ Bu projede If-Else yapÄ±sÄ±ndan ve Switch Case'den bahsedilmiÅŸtir.
+ Karar yapÄ±larÄ±, programÄ±n belirli koÅŸullara gÃ¶re farklÄ± yollar izlemesini saÄŸlayarak, akÄ±ÅŸ kontrolÃ¼nÃ¼ saÄŸlamaktadÄ±r.âš–ï¸

## 4. DÃ¶ngÃ¼ler | Loops ğŸ”
+ Bu Projede for ve while dÃ¶ngÃ¼leri ve bu dÃ¶ngÃ¼lerin karar yapÄ±larÄ± ile kullanÄ±mÄ±ndan bahsedilmiÅŸtir.
+ DÃ¶ngÃ¼ler, belirli bir iÅŸlemin tekrar edilmesi gereken durumlarda programÄ±n etkinliÄŸini artÄ±rarak kodun tekrarlanmasÄ±nÄ± Ã¶nler.ğŸ”„

## 5. YÄ±ldÄ±zlar DÃ¶ngÃ¼ | Loops With Stars ğŸŒŸâ™¾ï¸
+ Bu projede yÄ±ldÄ±z `*` kullanÄ±larak pratikler yapÄ±lmÄ±ÅŸtÄ±r ve farklÄ± desenler oluÅŸturulmuÅŸtur.
+ YÄ±ldÄ±z desenleri oluÅŸturma, dÃ¶ngÃ¼ ve kontrol yapÄ±larÄ±nÄ± pekiÅŸtirmek iÃ§in gÃ¶rsel bir yÃ¶ntem sunar.âœ¨

## 6. Diziler | Arrays ğŸ—‚ï¸
+ Bu projede temel dizi Ã¶rnekleri, dizideki elemanlarÄ± listeleme, dizi metotlarÄ± ve kullanÄ±cÄ±dan deÄŸer alarak dizi oluÅŸturulmadan bahsedilmiÅŸtir.
+ Diziler, birden fazla veriyi aynÄ± anda yÃ¶netmeyi kolaylaÅŸtÄ±rarak veri gruplarÄ±nÄ± iÅŸlemede esneklik saÄŸlar.ğŸ—„ï¸

## 7. Foreach DÃ¶ngÃ¼sÃ¼ | Foreach Loop ğŸ”‚
+ Bu projede foreach dÃ¶ngÃ¼sÃ¼nden bahsedilmiÅŸtir ve Ã¶nceki konular da baz alarak Ã¶rnek yapÄ±lmÄ±ÅŸtÄ±r.
+ Foreach dÃ¶ngÃ¼sÃ¼, koleksiyonlar Ã¼zerinde basit ve etkili bir ÅŸekilde iterasyon yaparak kodun okunabilirliÄŸini artÄ±rÄ±r.ğŸ”

## 8. Metotlar | Methods ğŸ› ï¸
+ Bu projede geriye deÄŸer dÃ¶ndÃ¼ren ve geriye deÄŸer dÃ¶ndÃ¼rmeyen metotlardan bahsedilmiÅŸtir. Bu iki tÃ¼r metota Ã¶zgÃ¼ Ã¶rnekler yapÄ±lmÄ±ÅŸtÄ±r.
+ Metotlar, kod tekrarÄ±nÄ± azaltarak modÃ¼lerlik saÄŸlar ve belirli gÃ¶revlerin ayrÄ± birimlerde yÃ¶netilmesine imkan tanÄ±r.ğŸ”§

## 9. VeritabanÄ± Projesi | Database Project ğŸ—ƒï¸
+ Bu projede bir C# proje ile SQL veri tabanÄ± uygulamasÄ±nÄ± Ado.Net kullanarak baÄŸlantÄ± kurulumundan bahsedilmiÅŸtir.
+ VeritabanÄ± projeleri, verilerin kalÄ±cÄ± olarak saklanmasÄ±nÄ± ve iÅŸlenmesini saÄŸlayarak dinamik uygulamalar geliÅŸtirmede temel bir rol oynar.ğŸ—„ï¸

## âœ¨MODÃœL 301

## 10. Veritaban CRUD | Database CRUD ğŸš€
+ `Create` â¡ï¸ VeritabanÄ±na yeni veri ekleme iÅŸlemi. `INSERT INTO` sorgusu veya ORM ile yapÄ±lÄ±r.
+ `Read` â¡ï¸ Verileri okuma ve gÃ¶rÃ¼ntÃ¼leme iÅŸlemi. `SELECT` sorgusu ile gerÃ§ekleÅŸtirilir.
+ `Update` â¡ï¸ Mevcut veriyi gÃ¼ncelleme iÅŸlemi. `UPDATE` sorgusu kullanÄ±lÄ±r.
+ `Delete` â¡ï¸ Veri silme iÅŸlemi. `DELETE FROM` sorgusu ile yapÄ±lÄ±r.

> ğŸ’¡CRUD iÅŸlemlerini veritabanÄ± yÃ¶netimi iÃ§in Entity Framework gibi ORM araÃ§larÄ± veya `SqlCommand` gibi class'larla kolayca uygulanabilmektedir.

## 11. Nesne YÃ¶nelimli Programlama ModÃ¼lÃ¼ | OOP Module: N-Tier Architecture Entity LayerğŸ› ï¸
+ `SÄ±nÄ±flar | Classes` â¡ï¸ Nesnelerin kalÄ±bÄ± olarak kullanÄ±lÄ±r. Her class, nesnelerin sahip olduÄŸu Ã¶zellikleri ve davranÄ±ÅŸlarÄ± tanÄ±mlar.
+ `Nesneler | Objects` â¡ï¸ Class'lardan tÃ¼retilen gerÃ§ek varlÄ±klardÄ±r; class'larÄ±n Ã¶rnekleridir.
+ `KapsÃ¼lleme | Encapsulation` â¡ï¸ Verileri ve iÅŸlevleri bir class iÃ§inde toplayarak gizliliÄŸi saÄŸlar.
+ `KalÄ±tÄ±m | Inheritance` â¡ï¸ Bir class'Ä±n baÅŸka bir class'Ä±n Ã¶zelliklerini miras almasÄ±nÄ± saÄŸlar.
+ `Ã‡ok BiÃ§imlilik | Polymorphism` â¡ï¸ AynÄ± iÅŸlemin farklÄ± class'larda farklÄ± biÃ§imlerde uygulanmasÄ±nÄ± saÄŸlar.
+ `Soyutlama | Abstraction` â¡ï¸ Gereksiz detaylarÄ± gizleyerek yalnÄ±zca gerekli bilgileri Ã¶ne Ã§Ä±karÄ±r.
> ğŸ’¡OOP programlamada esneklik saÄŸlar, kodu daha dÃ¼zenli ve anlaÅŸÄ±lÄ±r hale getirir.

+ N-Tier Architecture'da Entity Layer (VarlÄ±k KatmanÄ±), genellikle yazÄ±lÄ±m geliÅŸtirme sÃ¼recinde verilerin temsili ve iÅŸlenmesiyle ilgili iÅŸlemleri ele alan bir katmandÄ±r. Bu katman, uygulamanÄ±n temel veri modelini barÄ±ndÄ±rÄ±r ve diÄŸer katmanlar arasÄ±nda veri alÄ±ÅŸveriÅŸini kolaylaÅŸtÄ±rÄ±r.

##### Ã–zellikler:
1. `Veri Temsili:` UygulamanÄ±n iÅŸlediÄŸi gerÃ§ek dÃ¼nya nesnelerinin (Ã¶rneÄŸin, KullanÄ±cÄ±, SipariÅŸ, ÃœrÃ¼n) yazÄ±lÄ±m dÃ¼nyasÄ±ndaki temsilini saÄŸlar. Genellikle sÄ±nÄ±flar veya yapÄ±lar halinde tanÄ±mlanÄ±r.
2. `BaÄŸÄ±msÄ±zlÄ±k:` Entity Layer, genellikle uygulamanÄ±n iÅŸ mantÄ±ÄŸÄ± ve veri eriÅŸiminden baÄŸÄ±msÄ±z olarak tasarlanÄ±r, bÃ¶ylece diÄŸer katmanlarla minimum baÄŸÄ±mlÄ±lÄ±k yaratÄ±r.
3. `Veri DoÄŸrulama ve Ã–zellikler:` Veri Ã¼zerinde temel doÄŸrulama kurallarÄ±nÄ± veya Ã¶zellikleri iÃ§erebilir (Ã¶rneÄŸin, veri tÃ¼rleri, minimum/maksimum deÄŸerler).

##### KullanÄ±m:
+ `Data Transfer Objects (DTO):` Verilerin, farklÄ± katmanlar arasÄ±nda taÅŸÄ±nmasÄ± iÃ§in kullanÄ±lÄ±r.
+ `ORM Entegrasyonu:` Entity Layer genellikle bir ORM (Object-Relational Mapping) aracÄ±yla (Ã¶r. Entity Framework, Hibernate) veritabanÄ± tablolarÄ±yla iliÅŸkilendirilir.
+ `DÃ¼zenlilik ve ModÃ¼lerlik:` UygulamanÄ±n modÃ¼ler olmasÄ±nÄ± saÄŸlayarak kodun okunabilirliÄŸini ve bakÄ±mÄ±nÄ± artÄ±rÄ±r.

##### Avantajlar:
+ `Yeniden KullanÄ±labilirlik:` AynÄ± varlÄ±k sÄ±nÄ±flarÄ± birden Ã§ok katmanda kullanÄ±labilir.
+ `Sadelik:` Ä°ÅŸ mantÄ±ÄŸÄ± ve veri eriÅŸim mantÄ±ÄŸÄ±nÄ± soyutlayarak yalnÄ±zca veriyi temsil eder.
+ `BaÄŸÄ±msÄ±zlÄ±k:` Katmanlar arasÄ± baÄŸÄ±mlÄ±lÄ±klarÄ± azaltÄ±r, farklÄ± teknolojilerle kolayca entegre olabilir.

<strong>ğŸ“Œ`Entity Layer, iyi bir N-Tier Architecture tasarÄ±mÄ±nda kritik bir rol oynar, Ã§Ã¼nkÃ¼ tÃ¼m sistemin veri modellemesini merkezi bir yerde yÃ¶netir.`</strong>

## 12. Nesne YÃ¶nelimli Programlama ModÃ¼lÃ¼ | OOP Module: Data Access Layer & Context Class ğŸ› ï¸
### Data Access Layer (DAL)
+ Data Access Layer (Veri EriÅŸim KatmanÄ±), bir uygulamada veritabanÄ±yla etkileÅŸim kurmak iÃ§in kullanÄ±lan bir katmandÄ±r. UygulamanÄ±n diÄŸer katmanlarÄ±ndan veri eriÅŸim detaylarÄ±nÄ± soyutlayarak, veritabanÄ± iÅŸlemlerinin gÃ¼venli ve dÃ¼zenli bir ÅŸekilde gerÃ§ekleÅŸtirilmesini saÄŸlar.

##### GÃ¶revleri:
+ `VeritabanÄ± Ä°ÅŸlemleri:` CRUD (Create, Read, Update, Delete) iÅŸlemlerini gerÃ§ekleÅŸtirir.
+ `Soyutlama:` VeritabanÄ±na eriÅŸimle ilgili mantÄ±ÄŸÄ± iÅŸ mantÄ±ÄŸÄ±ndan ayÄ±rÄ±r.
+ `Performans Optimizasyonu:` Verimli sorgular oluÅŸturarak uygulamanÄ±n performansÄ±nÄ± artÄ±rÄ±r.

##### AvantajlarÄ± ğŸš€
+ Kodun tekrar kullanÄ±labilirliÄŸini artÄ±rÄ±r.
+ Veri eriÅŸimini yÃ¶netmek iÃ§in merkezi bir yapÄ± sunar.
+ VeritabanÄ± deÄŸiÅŸikliklerini uygulamanÄ±n geri kalanÄ±ndan izole eder.

### Context Class
+ Context Class, genellikle bir ORM (Object-Relational Mapping) aracÄ±yla kullanÄ±lÄ±r ve uygulamayla veritabanÄ± arasÄ±ndaki kÃ¶prÃ¼yÃ¼ saÄŸlar. En yaygÄ±n Ã¶rneÄŸi, Entity Framework'te kullanÄ±lan `DbContext` sÄ±nÄ±fÄ±dÄ±r.

##### GÃ¶revleri:
+ `VeritabanÄ± BaÄŸlantÄ±sÄ±:` VeritabanÄ± ile baÄŸlantÄ±yÄ± yÃ¶netir.
+ `Tablo-Model EÅŸleÅŸtirmesi:` VeritabanÄ±ndaki tablolarla, uygulama modellerini eÅŸleÅŸtirir.
+ `Sorgular ve Ä°ÅŸlemler:` VeritabanÄ± sorgularÄ±nÄ±n yÃ¼rÃ¼tÃ¼lmesini ve deÄŸiÅŸikliklerin kaydedilmesini saÄŸlar.

##### AvantajlarÄ± ğŸš€
+ VeritabanÄ± iÅŸlemlerinin kolayca kodlanmasÄ±nÄ± saÄŸlar.
+ Birden Ã§ok veri kaynaÄŸÄ±na baÄŸlanmak iÃ§in geniÅŸletilebilir.
+ ORM araÃ§larÄ±nÄ±n saÄŸladÄ±ÄŸÄ± avantajlardan yararlanÄ±r.

##### Data Access Layer ve Context Class ArasÄ±ndaki Ä°liÅŸki
+ Context Class, DAL iÃ§in temel saÄŸlar. VeritabanÄ±na baÄŸlantÄ±yÄ± ve modellerle tablolar arasÄ±ndaki iliÅŸkiyi yÃ¶netir.
+ DAL, Context Class kullanarak uygulamanÄ±n diÄŸer katmanlarÄ±na veritabanÄ± iÅŸlemleri iÃ§in bir API sunar.

<strong>ğŸ“Œ`Bu yapÄ±, N-Tier Architecture'Ä±n modÃ¼lerliÄŸini ve bakÄ±m kolaylÄ±ÄŸÄ±nÄ± destekler.`</strong>

## 13. Nesne YÃ¶nelimli Programlama ModÃ¼lÃ¼ | OOP Module: Migration & Abstract ğŸ› ï¸
### Migration (VeritabanÄ± GeÃ§iÅŸleri)
+ Migration, veritabanÄ± ÅŸemasÄ±ndaki (tablolar, kolonlar, iliÅŸkiler) deÄŸiÅŸiklikleri uygulamanÄ±n kod tabanÄ±ndaki deÄŸiÅŸikliklerle senkronize etmeyi saÄŸlayan bir yÃ¶ntemdir. Bu kavram genellikle Entity Framework gibi ORM araÃ§larÄ±nda kullanÄ±lÄ±r.

##### GÃ¶revleri:
+ `Åema YÃ¶netimi:` VeritabanÄ± ÅŸemasÄ±nÄ± versiyonlayarak deÄŸiÅŸiklikleri dÃ¼zenli bir ÅŸekilde uygulamanÄ±zÄ± saÄŸlar.
+ `DeÄŸiÅŸiklik KaydÄ±:` TablolarÄ±n eklenmesi, kolonlarÄ±n deÄŸiÅŸtirilmesi veya iliÅŸkilerin dÃ¼zenlenmesi gibi iÅŸlemleri kaydeder.
+ `Geri Alma:` Uygulanan deÄŸiÅŸiklikler gerektiÄŸinde geri alÄ±nabilir.

##### AvantajlarÄ± ğŸš€
+ Kod ve veritabanÄ± arasÄ±nda senkronizasyon saÄŸlar.
+ VeritabanÄ± deÄŸiÅŸikliklerini ekip iÃ§erisinde izlenebilir ve yÃ¶netilebilir kÄ±lar.
+ Otomatik ÅŸema oluÅŸturma ve gÃ¼ncelleme saÄŸlar.

### Abstract (Soyutlama)
+ Abstract, nesne yÃ¶nelimli programlamada kullanÄ±lan bir yapÄ± olup, temel olarak soyut sÄ±nÄ±flar veya metotlar tanÄ±mlamak iÃ§in kullanÄ±lÄ±r. Bu yapÄ±, ortak Ã¶zelliklerin ve davranÄ±ÅŸlarÄ±n alt sÄ±nÄ±flar tarafÄ±ndan zorunlu olarak uygulanmasÄ±nÄ± saÄŸlar.

##### Soyut SÄ±nÄ±f:
+ `TanÄ±m:` Kendi baÅŸÄ±na Ã¶rneklenemez (instance oluÅŸturulamaz). Alt sÄ±nÄ±flara temel bir yapÄ± saÄŸlar.
+ `GÃ¶rev:` Alt sÄ±nÄ±flarda uygulanmasÄ± gereken metotlarÄ± ve ortak Ã¶zellikleri tanÄ±mlar.

##### AvantajlarÄ± ğŸš€
+ Kodun tekrarÄ±nÄ± Ã¶nler ve ortak davranÄ±ÅŸlarÄ± merkezileÅŸtirir.
+ Polimorfizm (Ã§ok biÃ§imlilik) saÄŸlar.
+ Alt sÄ±nÄ±flar arasÄ±nda tutarlÄ±lÄ±ÄŸÄ± zorunlu kÄ±lar.

##### Data Access Layer ve Context Class ArasÄ±ndaki Ä°liÅŸki
+ `Migration:` VeritabanÄ± ÅŸemasÄ±nÄ± yÃ¶netmek iÃ§in kullanÄ±lÄ±r ve kod-veritabanÄ± uyumunu saÄŸlar.
+ `Abstract:` YazÄ±lÄ±mda soyutlama yaparak ortak davranÄ±ÅŸlarÄ±n dÃ¼zenli bir ÅŸekilde alt sÄ±nÄ±flar tarafÄ±ndan uygulanmasÄ±nÄ± saÄŸlar.

<strong>ğŸ“Œ`Her iki kavram, farklÄ± alanlarda dÃ¼zenlilik ve yapÄ± kazandÄ±rmayÄ± hedefler. Migration, veri yÃ¶netimi odaklÄ±dÄ±r; Abstract, yazÄ±lÄ±mÄ±n tasarÄ±mÄ± ve modÃ¼lerliÄŸi ile ilgilidir.`</strong>

## 14. ORM Structure: Entity Framework DbFirst & Create Model ğŸ› ï¸
+ Entity Framework DbFirst ve Model OluÅŸturma, mevcut bir veritabanÄ±ndan model ve context sÄ±nÄ±flarÄ± oluÅŸturarak veritabanÄ± ile kod arasÄ±nda bir baÄŸlantÄ± saÄŸlar. Bu yÃ¶ntem, veritabanÄ± tasarÄ±mÄ±nÄ±n uygulama kodundan Ã¶nce yapÄ±ldÄ±ÄŸÄ± senaryolarda kullanÄ±lÄ±r.

### DbFirst Nedir?
+ `TanÄ±m:` Mevcut bir veritabanÄ± ÅŸemasÄ±nÄ± temel alarak Entity Framework modellerini (entity sÄ±nÄ±flarÄ± ve context sÄ±nÄ±fÄ±nÄ±) otomatik olarak oluÅŸturma yÃ¶ntemidir.
+ `KullanÄ±m Senaryosu:` Ã–nceden oluÅŸturulmuÅŸ bir veritabanÄ± yapÄ±sÄ±nÄ±n olduÄŸu durumlarda tercih edilir.
+ `AmaÃ§:` VeritabanÄ±ndaki tablolar, iliÅŸkiler ve diÄŸer yapÄ±lar kodla uyumlu hale getirilir.

### DbFirst AvantajlarÄ± ve DezavantajlarÄ±
#### AvantajlarÄ±:
1. `HÄ±zlÄ± BaÅŸlangÄ±Ã§:` Mevcut veritabanÄ± yapÄ±sÄ±nÄ± hÄ±zlÄ±ca kod tarafÄ±na yansÄ±tabilirsiniz.
2. `Senkrone Olarak GÃ¼ncelleme:` VeritabanÄ± deÄŸiÅŸikliklerini yansÄ±tmak iÃ§in modeli yeniden oluÅŸturabilirsiniz.
3. `Manuel KodlamayÄ± AzaltÄ±r:` Tablolar ve iliÅŸkiler otomatik olarak sÄ±nÄ±flara Ã§evrilir.

#### DezavantajlarÄ±:
1. `Kod Ãœzerinde KontrolÃ¼n KÄ±sÄ±tlanmasÄ±:` Otomatik oluÅŸturulan sÄ±nÄ±flarda manuel dÃ¼zenleme yapmak sorunlara yol aÃ§abilir.
2. `GeliÅŸtirme SÃ¼recinde Esneklik KaybÄ±:` VeritabanÄ± tasarÄ±mÄ± deÄŸiÅŸirse, tekrar model oluÅŸturmak gerekebilir.

##### DbFirst ve CodeFirst KarÅŸÄ±laÅŸtÄ±rmasÄ±
|Ã–zellik|DbFirst|CodeFirst|
|-------|--------|---------|
|BaÅŸlangÄ±Ã§ NoktasÄ±|VeritabanÄ± tasarÄ±mÄ± Ã¶nce yapÄ±lÄ±r.|Kod yazÄ±larak veritabanÄ± otomatik oluÅŸturulur.|
|Esneklik|Daha az esnek, veritabanÄ± odaklÄ±dÄ±r.|Daha esnek, kod odaklÄ±dÄ±r.|
|Uygulama Senaryosu|Var olan veritabanÄ±nÄ± kullanma.|Yeni projelerde, veritabanÄ± tasarÄ±mÄ±na kodla baÅŸlama.|

<strong>ğŸ“Œ`DbFirst, mevcut bir veritabanÄ±nÄ± projeye entegre etmek iÃ§in ideal bir yÃ¶ntemdir ve Ã¶zellikle bÃ¼yÃ¼k projelerde zamandan tasarruf saÄŸlar.`</strong>

## 15. Entity Framework Methods & Project ğŸ› ï¸
Entity Framework (EF), bir .NET nesne-iliÅŸkisel eÅŸleme (ORM) aracÄ±dÄ±r ve veritabanÄ± iÅŸlemlerini daha kolay bir ÅŸekilde yapÄ±lmasÄ±na olanak saplar. Entity Framework, veritabanÄ± ile etkileÅŸim kurarken kullanÄ±lan Ã§eÅŸitli yÃ¶ntemler sunar.

###### Ä°ÅŸte en sÄ±k kullanÄ±lan EF yÃ¶ntemlerinin kÄ±sa aÃ§Ä±klamalarÄ±:
##### CRUD Ä°ÅŸlemleri
|Metot|GÃ¶revi|
|-------|--------|
|Add|VeritabanÄ±na yeni bir nesne eklemek iÃ§in kullanÄ±lÄ±r.|
|Find|Birincil anahtarÄ±na gÃ¶re bir nesneyi getirir.|
|Update|Mevcut bir nesnenin gÃ¼ncellenmesi iÃ§in kullanÄ±lÄ±r. DeÄŸiÅŸiklikler otomatik olarak izlenir.|
|Remove|Bir nesneyi veritabanÄ±ndan siler.|
|SaveChanges|YapÄ±lan tÃ¼m deÄŸiÅŸiklikleri veritabanÄ±na kaydeder.|

##### Sorgulama (Querying)
|Metot|GÃ¶revi|
|-------|--------|
|ToList|Bir sorgunun sonucunu liste olarak dÃ¶ner.|
|Where|Belirli bir koÅŸula gÃ¶re filtreleme yapar.|
|First / FirstOrDefault|Ä°lk kaydÄ± dÃ¶ner veya eÄŸer kayÄ±t yoksa `null` dÃ¶ner.|
|Single / SingleOrDefault|Tek bir kayÄ±t dÃ¶ner; eÄŸer birden fazla kayÄ±t varsa hata fÄ±rlatÄ±r. HiÃ§ yoksa `null` dÃ¶ner.|
|OrderBy / OrderByDescending|SÄ±ralama iÅŸlemleri iÃ§in kullanÄ±lÄ±r.|
|Include|Ä°liÅŸkili tablolarÄ± yÃ¼klemek iÃ§in kullanÄ±lÄ±r (Eager Loading).|
|Count|Sorgudan dÃ¶nen kayÄ±tlarÄ±n sayÄ±sÄ±nÄ± dÃ¶ner.|

##### Asenkron Metotlar
|Metot|GÃ¶revi|
|-------|--------|
|AddAsync|Yeni bir nesneyi asenkron olarak ekler.|
|FindAsync|Asenkron olarak birincil anahtara gÃ¶re nesneyi bulur.|
|ToListAsync|Asenkron olarak liste dÃ¶ner.|
|FirstOrDefaultAsync / SingleOrDefaultAsync|Belirli bir koÅŸula gÃ¶re ilk kaydÄ± veya tek kaydÄ± asenkron olarak dÃ¶ner.|

<strong>ğŸ“Œ`Entity Framework yÃ¶ntemleri ile hem basit hem de karmaÅŸÄ±k veritabanÄ± iÅŸlemlerini kolayca gerÃ§ekleÅŸtirebilirsiniz. Bu yÃ¶ntemler LINQ ile birlikte gÃ¼Ã§lÃ¼ bir araÃ§ seti sunar.`</strong>

## 16. Entity Framework: Project ğŸ› ï¸
CRUD iÅŸlemleri uygulanarak Location tablosundaki iÅŸlemler yapÄ±ldÄ±.

## 17. Entity Framework Methods & Linq ğŸ› ï¸
LINQ (Language Integrated Query), C# ve .NET dillerinde kullanÄ±lan gÃ¼Ã§lÃ¼ bir sorgulama mekanizmasÄ±dÄ±r. LINQ kullanÄ±larak veritabanlarÄ±, koleksiyonlar, XML ve diÄŸer veri kaynaklarÄ± Ã¼zerinde kolayca sorgulamalar yapÄ±labilir.

###### Ä°ÅŸte LINQ ile ilgili sÄ±k sorulan sorular ve bunlara dair kÄ±sa aÃ§Ä±klamalar:
### Temel LINQ SorularÄ±
1. LINQ nedir?
+ LINQ, verileri sorgulamak iÃ§in kullanÄ±lan bir sorgulama dilidir. SQL'e benzer ÅŸekilde Ã§alÄ±ÅŸÄ±r ancak farklÄ± veri kaynaklarÄ±nÄ± (koleksiyonlar, veritabanlarÄ±, XML vb.) sorgulamak iÃ§in kullanÄ±lÄ±r.

2. LINQ TÃ¼rleri Nelerdir?

|    |AÃ§Ä±klama|
|-------|--------|
|LINQ to Objects|Koleksiyonlar Ã¼zerinde Ã§alÄ±ÅŸÄ±r.|
|LINQ to SQL|SQL Server veritabanlarÄ± ile Ã§alÄ±ÅŸÄ±r.|
|LINQ to XML|XML verileri ile Ã§alÄ±ÅŸÄ±r.|
|LINQ to Entities|Entity Framework veritabanÄ± sorgularÄ± iÃ§in kullanÄ±lÄ±r.|

3. LINQ SorgularÄ±nda KullanÄ±lan Temel OperatÃ¶rler Nelerdir?

|    |AÃ§Ä±klama|
|-------|--------|
|Select|Veri seÃ§mek iÃ§in kullanÄ±lÄ±r.|
|Where|Filtreleme yapar.|
|OrderBy / OrderByDescending|SÄ±ralama yapar.|
|GroupBy|Gruplama yapar.|
|Join|FarklÄ± veri kaynaklarÄ±nÄ± birleÅŸtirir.|

4. LINQ ile SQL ArasÄ±ndaki Farklar Nelerdir?
+ SQL sadece veritabanÄ± sorgularÄ± iÃ§in kullanÄ±lÄ±rken LINQ, her tÃ¼r veri kaynaÄŸÄ± Ã¼zerinde Ã§alÄ±ÅŸabilir.
+ LINQ, C# diline entegredir; bu nedenle IntelliSense gibi Ã¶zellikler sunar.

### Performans

|Soru|Cevap|
|-------|--------|
| LINQ performansÄ± nasÄ±ldÄ±r?| LINQ sorgularÄ± okunabilirlik aÃ§Ä±sÄ±ndan avantajlÄ±dÄ±r ancak bazÄ± durumlarda performans aÃ§Ä±sÄ±ndan optimize edilmelidir. Ã–rneÄŸin, bÃ¼yÃ¼k veri setlerinde sorgular mÃ¼mkÃ¼nse `ToList()` veya `AsEnumerable()` gibi yÃ¶ntemler kullanmadan yapÄ±lmalÄ±dÄ±r.|
|LINQ sorgularÄ± nasÄ±l optimize edilir?|Filtreleme iÅŸlemlerini mÃ¼mkÃ¼n olduÄŸunca erken yapÄ±lmalÄ±. Gereksiz veri taÅŸÄ±mayÄ± Ã¶nlemek iÃ§in sadece ihtiyaÃ§ duyulan alanlar `Select` ile seÃ§ilmeli. Lazy Loading ve Eager Loading arasÄ±ndaki farklara dikkat edilmeli.|

<strong>ğŸ“Œ`LINQ, doÄŸru kullanÄ±ldÄ±ÄŸÄ±nda oldukÃ§a gÃ¼Ã§lÃ¼ ve esnek bir araÃ§tÄ±r; dolayÄ±sÄ±yla bu tÃ¼r sorularÄ± anlamak ve uygulamak, hem teorik hem de pratik bilgiyi iÃ§erir.`</strong>

## Ders 17 Case GÃ¶revi
![Ekran gÃ¶rÃ¼ntÃ¼sÃ¼ 2024-11-27 094959](https://github.com/user-attachments/assets/7988bfbf-a626-44a9-bae2-6cde36e52a7c)

## 18. EntityState KomutlarÄ±, Generic Repostory Class & EF Class ğŸ› ï¸
### EntityState KomutlarÄ± ğŸ—‚ï¸
+ EntityState, Entity Framework'te bir nesnenin veritabanÄ±ndaki durumunu kontrol etmek ve iÅŸlem yapmak iÃ§in kullanÄ±lÄ±r.

+ `Added` â¡ï¸ VeritabanÄ±na bir yeni kayÄ±t olarak eklenmesi (INSERT).
+ `Modified` â¡ï¸ VeritabanÄ±nda gÃ¼ncelleme iÅŸlemi yapÄ±lmasÄ± (UPDATE).
+ `Deleted` â¡ï¸ VeritabanÄ±ndan silinmesi (DELETE).
+ `Unchanged` â¡ï¸ VeritabanÄ±nda hiÃ§bir iÅŸlem yapÄ±lmamasÄ±.
+ `Detached` â¡ï¸ VarlÄ±k baÄŸÄ±msÄ±z bÄ±rakÄ±lÄ±r, bellekten silinmemesi.

<strong>ğŸ“Œ`Not: EntityState, SaveChanges() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda uygulanÄ±r. Bu, bir varlÄ±ÄŸÄ±n ne ÅŸekilde iÅŸleneceÄŸini belirler ve veritabanÄ±na uygun iÅŸlemleri yansÄ±tÄ±r.`</strong>

### Generic Repository Class ğŸ“¦
+ Nedir?
  - TÃ¼m CRUD iÅŸlemleri iÃ§in tekrar eden kodlarÄ± azaltan, genel bir yapÄ± saÄŸlar.
  - `TEntity` gibi bir tÃ¼r parametresi ile herhangi bir tablo veya varlÄ±k Ã¼zerinde Ã§alÄ±ÅŸabilir.

+ AvantajlarÄ± ğŸš€
  - TekrarÄ± Ã¶nler.
  - Kodunuzu daha temiz ve yÃ¶netilebilir hale getirir.
  - TÃ¼m veri eriÅŸim iÅŸlemleri tek bir yapÄ± altÄ±nda toplanÄ±r.

+ ###### Ã–rnek:
```
public interface IGenericRepository<T> where T : class
{
    Task<IEnumerable<T>> GetAllAsync();
    Task<T> GetByIdAsync(int id);
    Task AddAsync(T entity);
    void Update(T entity);
    void Delete(T entity);
}
```

### Entity Framework (FE) Class âš™ï¸
+ Nedir?
  - Entity Framework (EF), .NET iÃ§in bir ORM (Object-Relational Mapping) aracÄ±dÄ±r. VeritabanÄ± iÅŸlemlerini C# nesneleriyle Ã§alÄ±ÅŸarak kolaylaÅŸtÄ±rÄ±r.

+ EF SÄ±nÄ±flarÄ±nÄ±n GÃ¶revleri
  - `DbContext:` VeritabanÄ± baÄŸlantÄ±sÄ± ve iÅŸlemleri iÃ§in ana sÄ±nÄ±f.
  - `DbSet:` Belirli bir tabloyu temsil eder ve sorgulama/gÃ¼ncelleme iÅŸlemleri iÃ§in kullanÄ±lÄ±r.
+ ###### Ã–rnek EF Class
```
public class AppDbContext : DbContext
{
    public DbSet<Product> Products { get; set; }
    public DbSet<Category> Categories { get; set; }
    
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("YourConnectionString");
    }
}
```

<strong>ğŸ“Œ`Not: Generic Repository Class, EF ile birlikte Ã§alÄ±ÅŸarak veritabanÄ± iÅŸlemlerini daha dÃ¼zenli ve verimli bir hale getirir.`</strong>

## 19. Business KatmanÄ± & Logic Kurallar ğŸ› ï¸
### Business KatmanÄ± ğŸ¢
+ Nedir?
  - Ä°ÅŸ kurallarÄ±nÄ± ve mantÄ±ÄŸÄ±nÄ± iÃ§eren uygulama katmanÄ±dÄ±r. UygulamanÄ±n veri iÅŸleme ve iÅŸ kurallarÄ±nÄ± (business rules) yÃ¶netir.

+ GÃ¶revleri
  - VeritabanÄ±ndan gelen veriyi iÅŸleyip kontrol etmek.
  - Ä°ÅŸ kurallarÄ±nÄ± uygulayarak veri akÄ±ÅŸÄ±nÄ± saÄŸlamak.
  - UI (KullanÄ±cÄ± ArayÃ¼zÃ¼) ve Data Access (Veri KatmanÄ±) arasÄ±nda bir kÃ¶prÃ¼ oluÅŸturmak.
    
<strong>ğŸ“Œ`Not: Business katmanÄ±, veritabanÄ± iÅŸlemlerinden baÄŸÄ±msÄ±zdÄ±r ve yalnÄ±zca iÅŸ mantÄ±ÄŸÄ±na odaklanÄ±r.`</strong>

### Logic Kurallar âš–ï¸
+ Uygulama iÃ§inde belirli durumlar iÃ§in tanÄ±mlanan iÅŸ mantÄ±klarÄ± ve kurallar bÃ¼tÃ¼nÃ¼dÃ¼r.
+ Ã–rneÄŸin:
  - KullanÄ±cÄ±ya ait verilerin belirli kriterlere gÃ¶re doÄŸrulanmasÄ±.
  - Ä°ndirimlerin yalnÄ±zca belirli koÅŸullarda uygulanmasÄ±.
  - KullanÄ±cÄ± rolleri bazÄ±nda yetkilendirme.

+ ###### Ã–rnek Logic Kurallar
```
if (order.TotalAmount > 1000)
{
    ApplyDiscount(order, 10); // 1000 TL Ã¼zeri sipariÅŸlere %10 indirim uygula
}

if (!user.IsActive)
{
    throw new Exception("KullanÄ±cÄ± aktif deÄŸil!"); // Aktif olmayan kullanÄ±cÄ±lar iÃ§in hata fÄ±rlat
}
```

<strong>ğŸ“Œ`Not: Logic kurallar, hem veritabanÄ±ndan gelen veriler Ã¼zerinde kontrol saÄŸlar hem de uygulamanÄ±n doÄŸru Ã§alÄ±ÅŸmasÄ±nÄ± garanti eder.`</strong>

### Business KatmanÄ± ile Logic KurallarÄ±n Uyumu ğŸ¤
Business katmanÄ±, logic kurallarÄ±nÄ± uygulayarak iÅŸ sÃ¼reÃ§lerini yÃ¼rÃ¼tÃ¼r. Bu yapÄ±yÄ± kullanarak:
+ Kod tekrarÄ±nÄ± Ã¶nlenir.
+ Ä°ÅŸ kurallarÄ±nÄ± daha kolay yÃ¶netilir.
+ UygulamanÄ±z daha okunabilir ve modÃ¼ler hale gelir.

###### Ã–rnek Business KatmanÄ±
```
public class OrderManager : IOrderService
{
    public void PlaceOrder(Order order)
    {
        if (order.TotalAmount <= 0)
        {
            throw new Exception("SipariÅŸ tutarÄ± sÄ±fÄ±rdan bÃ¼yÃ¼k olmalÄ±!");
        }
        // Ä°ÅŸ kurallarÄ±nÄ± uygula ve sipariÅŸi tamamla
    }
}
```

## 20. Dependency Injection (DI) ğŸ› ï¸
### Nedir?
  - Dependency Injection, bir sÄ±nÄ±fÄ±n baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± (Ã¶rneÄŸin, baÅŸka bir sÄ±nÄ±fÄ± veya servisi) doÄŸrudan kendisinin oluÅŸturmasÄ± yerine, dÄ±ÅŸarÄ±dan almasÄ±nÄ± saÄŸlayan bir tasarÄ±m desenidir.
  
### AvantajlarÄ± ğŸš€
  - `GevÅŸek BaÄŸlÄ±lÄ±k (Loose Coupling):` SÄ±nÄ±flar birbirine sÄ±kÄ± sÄ±kÄ±ya baÄŸlÄ± olmaz.
  - `Test Edilebilirlik:` BaÄŸÄ±mlÄ±lÄ±klarÄ±n kolayca deÄŸiÅŸtirilmesi, birimleri daha kolay test edilebilir hale getirir.
  - `Esneklik:` UygulamanÄ±n geniÅŸletilmesi ve bakÄ±mÄ± kolaylaÅŸÄ±r.
 
#### DI TÃ¼rleri
1. `Constructor Injection:` BaÄŸÄ±mlÄ±lÄ±klar sÄ±nÄ±fÄ±n kurucusuna (`constructor`) enjekte edilir.
```
public class OrderManager
{
    private readonly IOrderService _orderService;

    public OrderManager(IOrderService orderService)
    {
        _orderService = orderService;
    }
}
```

2. `Property Injection:` BaÄŸÄ±mlÄ±lÄ±klar bir Ã¶zelliÄŸe (`property`) enjekte edilir.
```
public class OrderManager
{
    public IOrderService OrderService { get; set; }
}
```

3. `Method Injection:` BaÄŸÄ±mlÄ±lÄ±klar bir metoda enjekte edilir.
```
public void PlaceOrder(IOrderService orderService)
{
    orderService.ProcessOrder();
}
```

<strong>ğŸ“Œ`Not: Dependency Injection, modern uygulama geliÅŸtirmede modÃ¼lerlik, esneklik ve test edilebilirlik saÄŸlamak iÃ§in vazgeÃ§ilmez bir yaklaÅŸÄ±mdÄ±r.`</strong>

## 21. Entity'e Ã–zgÃ¼ Metot Yazmak ğŸ› ï¸
+ Entity Framework'te (EF) her entity iÃ§in Ã¶zelleÅŸtirilmiÅŸ metotlar yazarak, iÅŸ ihtiyaÃ§larÄ±na gÃ¶re veri iÅŸlemleri gerÃ§ekleÅŸtirebilir. Bu metotlar, genellikle repository veya service sÄ±nÄ±flarÄ±nda tanÄ±mlanÄ±r ve Entity Framework'Ã¼n sunduÄŸu gÃ¼Ã§lÃ¼ sorgulama Ã¶zelliklerinden yararlanÄ±r.
+ ###### Ã–rnek: Belirli bir kategorideki Ã¼rÃ¼nleri listeleme, en Ã§ok satan Ã¼rÃ¼nleri getirme gibi.

### Kod Ã–rneÄŸi ğŸ§‘â€ğŸ’»ğŸ“‹
1. VarlÄ±ÄŸa Ã–zgÃ¼ Bir Metot TanÄ±mlama
###### AmaÃ§: Belirli bir kategoriye ait Ã¼rÃ¼nleri getirme.
```
public class ProductRepository
{
    private readonly AppDbContext _context;

    public ProductRepository(AppDbContext context)
    {
        _context = context;
    }

    // Belirli bir kategorideki Ã¼rÃ¼nleri getir
    public List<Product> GetProductsByCategory(int categoryId)
    {
        return _context.Products
            .Where(p => p.CategoryId == categoryId)
            .ToList();
    }
}
```

2. KarmaÅŸÄ±k Ä°ÅŸlemler Ä°Ã§in Metot Yazma
###### AmaÃ§: Stok durumu azalan Ã¼rÃ¼nleri listeleme.
```
public List<Product> GetLowStockProducts(int threshold)
{
    return _context.Products
        .Where(p => p.Stock < threshold)
        .OrderBy(p => p.Stock)
        .ToList();
}
```

### MetotlarÄ±n Ã–rnek Ã‡aÄŸrÄ±mÄ± ğŸ–¥ï¸
```
var productService = new ProductService(new ProductRepository(context));

// Belirli kategori iÃ§in Ã¼rÃ¼nleri getir
var categoryProducts = productService.GetProductsByCategory(3);

// Stok seviyesi dÃ¼ÅŸÃ¼k Ã¼rÃ¼nleri getir
var lowStockProducts = productService.GetLowStockProducts(10);
```

### Ã–zet ğŸ—‚ï¸
+ Entity'ye Ã¶zgÃ¼ metotlar, iÅŸ ihtiyaÃ§larÄ±na uygun, temiz ve yÃ¶netilebilir kod yazmayÄ± kolaylaÅŸtÄ±rÄ±r. Bu metotlarla birlikte:
  - KarmaÅŸÄ±k sorgular bir kez yazÄ±lÄ±r ve tekrar kullanÄ±labilir hale gelir.
  - VeritabanÄ± iÅŸlemleri daha dÃ¼zenli bir ÅŸekilde yÃ¶netilir.
  - Performans optimizasyonu saÄŸlanÄ±r.

<strong>ğŸ“Œ`Bu metotlar, hem kod kalitesini artÄ±rÄ±r hem de uygulamanÄ±n bakÄ±mÄ±nÄ± kolaylaÅŸtÄ±rÄ±r. ğŸš€`</strong>

## 22. - 23. C# Ä°le Dapper KullanÄ±mÄ± ğŸ“œ
### Nedir?
+ Dapper, .NET platformu iÃ§in hafif, hÄ±zlÄ± ve esnek bir Micro ORM (Object-Relational Mapper) kÃ¼tÃ¼phanesidir.
+ SQL sorgularÄ±nÄ± kullanarak veritabanÄ± iÅŸlemlerini daha kolay ve performanslÄ± bir ÅŸekilde yapmanÄ±za olanak tanÄ±r.

### Ã–zellikleri ğŸŒŸ
+ `Hafif:` Minimal bir kod ile Ã§alÄ±ÅŸÄ±r, ek yÃ¼k oluÅŸturmaz.
+ `HÄ±zlÄ±:` Performans odaklÄ±dÄ±r ve ham ADO.NET kadar hÄ±zlÄ±dÄ±r.
+ `Esnek:` SQL sorgularÄ±nÄ± doÄŸrudan yazmanÄ±za izin verir, bÃ¶ylece tam kontrol saÄŸlar.
+ `Kolay Entegrasyon:` Mevcut projelere hÄ±zlÄ±ca eklenebilir.

### AvantajlarÄ± ğŸš€
+ Daha hÄ±zlÄ± ve esnek CRUD iÅŸlemleri.
+ ORM'lerin karmaÅŸÄ±klÄ±ÄŸÄ±ndan uzak, kontrolÃ¼n sizde olduÄŸu bir yapÄ±.
+ Basit kurulum ve kullanÄ±m.
+ DesteklediÄŸi veri tiplerini otomatik olarak eÅŸler.

###### Dapper KullanÄ±m Ã–rneÄŸi
```
using Dapper;
using System.Data.SqlClient;

public class ProductRepository
{
    private readonly string _connectionString = "YourConnectionString";

    public IEnumerable<Product> GetAllProducts()
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            string sql = "SELECT * FROM Products";
            return connection.Query<Product>(sql);
        }
    }

    public void AddProduct(Product product)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            string sql = "INSERT INTO Products (Name, Price) VALUES (@Name, @Price)";
            connection.Execute(sql, product);
        }
    }
}
```

#### Dapper vs. Entity Framework âš–ï¸
|Ã–zellik|Dapper|Entity Framework|
|-------|------|----------------|
|Performans|Daha hÄ±zlÄ±|ORM katmanÄ± nedeniyle daha yavaÅŸ|
|SQL KontrolÃ¼|Tam kontrol saÄŸlar|Daha az kontrol|
|Ã–ÄŸrenme EÄŸrisi|Basit ve hÄ±zlÄ±|Daha karmaÅŸÄ±k|
|Ã–zelleÅŸtirme|Kolayca Ã¶zelleÅŸtirilebilir|ORM yapÄ±sÄ±na baÄŸlÄ± kalÄ±r|

<strong>ğŸ“Œ`Dapper, basit ve performans odaklÄ± bir Ã§Ã¶zÃ¼m arayanlar iÃ§in ideal bir seÃ§enektir. Ã–zellikle bÃ¼yÃ¼k ve karmaÅŸÄ±k ORM yapÄ±larÄ± yerine daha fazla kontrol isteyen projelerde tercih edilir.`</strong>

## 24. - 25. C# ile MongoDb ğŸƒ
### Nedir?
+ MongoDB, aÃ§Ä±k kaynaklÄ± ve belge tabanlÄ± bir NoSQL veritabanÄ± yÃ¶netim sistemidir. Geleneksel iliÅŸkisel veritabanlarÄ±ndan farklÄ± olarak, verileri JSON benzeri belgeler (`document`) ÅŸeklinde depolar.

### Ã–zellikleri ğŸŒŸ
+ `Esnek YapÄ±:` ÅemasÄ± olmayan bir yapÄ±ya sahiptir, bu nedenle veriler dinamik bir ÅŸekilde depolanabilir.
+ `YÃ¼ksek Performans:` BÃ¼yÃ¼k veri kÃ¼melerinde hÄ±zlÄ± okuma ve yazma iÅŸlemleri saÄŸlar.
+ `Yatay Ã–lÃ§eklenebilirlik:` BÃ¼yÃ¼k veri setlerini iÅŸlemek iÃ§in kolayca Ã¶lÃ§eklenebilir.
+ `Zengin Sorgu DesteÄŸi:` Verileri esnek sorgularla filtreleyebilir ve analiz edebilirsiniz.

### AvantajlarÄ± ğŸš€
+ `HÄ±zlÄ± GeliÅŸtirme:` Åema tanÄ±mlama zorunluluÄŸu olmadÄ±ÄŸÄ± iÃ§in deÄŸiÅŸiklikler daha kolay uygulanÄ±r.
+ `Esneklik:` FarklÄ± tÃ¼rde ve yapÄ±da veriler aynÄ± koleksiyonda saklanabilir.
+ `JSON Benzeri Belgeler:` Veriler, programlama dillerindeki veri yapÄ±larÄ± ile kolayca uyumludur.

### Temel Kavramlar ğŸ—‚ï¸
+ `Database:` Birden fazla koleksiyonun saklandÄ±ÄŸÄ± ana yapÄ±.
+ `Collection (Koleksiyon):` Tabloya benzer, belgelerin saklandÄ±ÄŸÄ± yapÄ±.
+ `Document (Belge):` JSON formatÄ±na benzer, veri kayÄ±tlarÄ±nÄ± tutar. Ã–rneÄŸin:
  ```
  {
    "_id": "1",
    "name": "John Doe",
    "age": 30,
    "skills": ["C#", "MongoDB"]
  }
  ```

<strong>ğŸ“Œ`MongoDB, Ã¶zellikle bÃ¼yÃ¼k ve hÄ±zlÄ± deÄŸiÅŸen veri setleri ile Ã§alÄ±ÅŸmak iÃ§in mÃ¼kemmel bir seÃ§imdir. Esneklik ve Ã¶lÃ§eklenebilirlik isteyen projelerde sÄ±kÃ§a kullanÄ±lÄ±r.`</strong>

## 26. C# ile PostgreSQL ğŸ˜
### Nedir? 
+ PostgreSQL, gÃ¼Ã§lÃ¼ bir aÃ§Ä±k kaynaklÄ± iliÅŸkisel veritabanÄ± yÃ¶netim sistemidir (RDBMS). YÃ¼ksek performans, geniÅŸ Ã¶zellik seti ve esneklik sunar.

### Ã–zellikleri ğŸŒŸ
+ `ACID UyumluluÄŸu:` Veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ ve gÃ¼venilirliÄŸini saÄŸlar.
+ `JSON ve XML DesteÄŸi:` YapÄ±landÄ±rÄ±lmamÄ±ÅŸ verilerle Ã§alÄ±ÅŸma imkanÄ± sunar.
+ `GeliÅŸmiÅŸ Sorgu DesteÄŸi:` KarmaÅŸÄ±k sorgularÄ± kolayca Ã§alÄ±ÅŸtÄ±rabilir.
+ `Hata ToleransÄ±:` GÃ¼Ã§lÃ¼ kurtarma mekanizmalarÄ± sayesinde gÃ¼venilirlik sunar.
+ `UzantÄ±lar:` PostGIS gibi uzantÄ±larla iÅŸlevsellik artÄ±rÄ±labilir.

### AvantalarÄ± ğŸš€
+ `PerformanslÄ±:` BÃ¼yÃ¼k veri kÃ¼melerinde dahi etkili Ã§alÄ±ÅŸÄ±r.
+ `Esnek:` Geleneksel tablolardan JSON belgelerine kadar farklÄ± veri tÃ¼rlerini destekler.
+ `AÃ§Ä±k Kaynak:` TÃ¼mÃ¼yle Ã¼cretsiz ve topluluk desteklidir.
+ `Platform BaÄŸÄ±msÄ±z:` Ã‡eÅŸitli iÅŸletim sistemlerinde Ã§alÄ±ÅŸabilir.

### Temel Kavramlar ğŸ—‚ï¸
+ `Tablo (Table):` Verilerin satÄ±r ve sÃ¼tunlar halinde dÃ¼zenlendiÄŸi yapÄ±.
+ `SatÄ±r (Row):` Verinin tek bir kaydÄ±nÄ± temsil eder.
+ `SÃ¼tun (Column):` Verilerin tÃ¼rÃ¼nÃ¼ veya kategorisini belirler.
+ `Primary Key:` Her satÄ±rÄ± benzersiz ÅŸekilde tanÄ±mlayan sÃ¼tun.
+ `Foreign Key:` Ä°ki tablo arasÄ±ndaki iliÅŸkiyi tanÄ±mlar.

### KullanÄ±m ğŸ› ï¸
+ VeritabanÄ± OluÅŸturma
```
CREATE DATABASE exampledb;
```

+ Tablo OluÅŸturma
```
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    age INT
);
```

+ Veri Ekleme
```
INSERT INTO users (name, age) VALUES ('John Doe', 30);
```

+ Veri Silme
```
DELETE FROM users WHERE id = 1;
```

+ Veri Sorgulama
```
SELECT * FROM users;
```

+ Tablo GÃ¼ncelleme
```
UPDATE users SET age = 31 WHERE id = 1;
```

### Neden PostgreSQL? ğŸ§
+ BÃ¼yÃ¼k veri projelerinde etkili.
+ YÃ¼ksek gÃ¼venlik ve veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼ saÄŸlÄ±yor.
+ Topluluk ve kurumsal destek bir arada.

<strong>ğŸ“Œ`PostgreSQL, hem esnek hem de gÃ¼Ã§lÃ¼ yapÄ±sÄ±yla modern uygulamalar iÃ§in mÃ¼kemmel bir seÃ§imdir!`</strong>
